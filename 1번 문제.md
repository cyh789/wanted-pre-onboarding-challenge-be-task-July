- (1) 동시에 같은 `DB Table row` 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.
  
우리가 제공하는 서비스는 다수의 사용자를 가정하기 때문에 다중 트랜잭션의 상호 간섭 작용에서 데이터의 정합성을 보장 할 수 있어야 합니다(ACID). 이를 동시성 제어라고 하며, 크게 Application / DBMS / Global 레벨에서의 제어 방법이 있습니다.  
</br>
먼저 Application 레벨에서의 동시성 제어는, 자바를 이용하여 개발한다는 가정하에, 싱글 프로세스라면 코드 레벨에서 Syncronized 키워드의 이용을 고려해 볼 수 있습니다.  
다만 해당 키워드는 멀티 프로세스 환경에서는 DB의 정합성(ACID)을 보장해주지 못하기에 다중 서버를 두는 경우에는 사용할 수 없으며, 싱글 서버라고 하더라도 추후 변동가능성이 높기에 바람직하지는 못한 것 같습니다.  
</br>
</br>
다음으로, DBMS(Mysql) 레벨에서의 동시성 제어는 LOCK을 이용하여 구현 가능합니다.  
</br>
동시성 제어의 목표는 동시에 실행되는 트랜잭션의 수를 최대화하면서도 입력/수정/삭제/검색 시 데이터 무결성이 유지되도록 하는데에 있는데, 동시성과 일관성(데이터 정합성)이 트레이드 오프 관계에 있기 때문에 이에 대한 해석이 다양하여 여러가지 해결 방법이 제시되고 있습니다.  
대표적으로, 비관적 잠금과 낙관적 잠금을 통해 동시성을 제어하여 부정합 문제가 발생하는 상황에 대비 가능합니다.(네임드 락도 가능)  
</br>
비관적 잠금은, 말 그대로 사용자들이 같은 데이터를 동시에 수정할 것이라고 비관적으로 가정하여, select ~ for update (+nowait, +wait 3) 등으로 실제 데이터에 락을 걸어서 정합성을 보장하는 방법입니다.  
빈번하게 롤백(충돌)이 일어날 것으로 예상되는 경우에 사용한다면, 충돌로 인한 롤백의 횟수를 최소화하여 퍼포먼스의 향상을 기대 할 수 있으며.  
또한 데이터의 무결성을 보장하는 수준이 매우 높다는 장점이 있습니다.  
</br>
다만, 서로 다른 트랜잭션에서 서로의 자원이 필요 한 경우 데드락 발생 가능성이 있고, 낙관적 잠금에 비해 락을 점유하는 시간이 추가되므로 성능의 저하가 있을 수 있습니다.  
특히 읽기가 많이 이루어지는 데이터베이스의 경우 퍼포먼스에 큰 영향을 줄 수 있습니다.  
</br>
낙관적 잠금은, 말 그대로 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 낙관적으로 가정하여, 버저닝을 통하여 데이터에 락을 거는것이 아니라 충돌 자체를 방지하는 식으로 (동시성 제어를 통해) 정합성을 보장하는 방법입니다.  
읽기에서 락 잠금을 사용하지 않기 때문에 성능이 좋으며, 동시 업데이트가 없는 경우에 이 방법을 사용하면 비관적 잠금보다 빠르게 조회 및 업데이트를 할 수 있습니다.  
</br>
별도의 락을 거는 방식은 아니기에 성능상 이점이 있으나, 버전이 맞지않아 sql 질의가 실패한 상황에서의 후처리 로직을 application 단에서 개발자가 직접 작성해야 한다는 단점이 있습니다.  
충돌이 발생하지 않는다는 가정하에, 동시 요청에 대한 처리 성능이 뛰어나지만,  찾은 충돌이 발생하는 경우 롤백 및 SQL질의 재수행 등 후처리 로직에 대한 비용이 많이 발생하기 때문에 오히려 퍼포먼스의 저하가 있을 수 있습니다.  
</br>
상기 서술한 동시성 제어 기법들만을 사용 할 경우, Locking 매커니즘의 문제점이 있기에 읽기 작업과 쓰기 작업이 서로를 방해하여 동시성을 떨어뜨리거나 데이터의 일관성을 훼손하는 경우가 발생 가능합니다.  
이에 대하여 요즘에는 DMBS에서 다중버전 동시성 제어(MVCC)를 지원하여 읽기 일관성을 보장하고 있습니다.  
</br>
다만, MVCC 역시 문장 수준 읽기 일관성을 지원하는 것이지, 트랜잭션 수준의 읽기 일관성을 제공하는 것은 아니기에 완벽한 읽기 일관성을 보장받을 수는 없습니다. (격리 레벨을 Serializable Read로 상향 조정하면 가능하나 성능의 문제로 인해 사실상 불가능)  
또한, Snapshot too old 에러가 발생 가능하여 대용량 데이터를 처리 할 경우에 문제가 될 수 있습니다.  
</br>
</br>
추가로, 네임드 락이 있습니다. 이는 Mysql에서 분산 락을 이용하는 방식으로, 비관적 잠금과 유사하나 table/row 단위가 아니라 메타데이터 단위로 락을 건다는 점에서 차이가 있습니다.  
사용시 Transaction이 종료 될 떄 락이 자동으로 해제되지 않기 때문에, 반드시 별도의 명령어로 해제를 수행해 주거나 선점 시간이 종료되어야 해제가 가능합니다.  
</br>
분산된 서버 또는 데이터베이스 환경에서도 동시성을 제어할 수 있는 방법으로 하기 서술 할 Redis와 비교하여 메모리(RAM) 자원을 추가로 사용할 필요가 없다는 장점을 가지고 있습니다. 그러나 기본적으로 디스크를 사용하는 DBMS의 특징상 메모리(RAM)를 사용하는 Redis에 비해 락의 획득 및 해제가 더 느리다는 단점이 있습니다.  
</br>
</br>
마지막으로, Global 레벨에서의 동시성 제어는 Redis(분산 락: Distributed Lock)를 이용하여 구현 가능합니다.  
</br>
Redis는, Single-Thread 기반이기 때문에 멀티쓰레드 환경에서 다수의 요청이 들어오더라도 wait Queue에서 대기하도록 하여 연산의 원자성을 보장받을 수 있습니다. (트랜잭션 수준의 읽기 일관성)  
</br>
성능에 대해서도, Redis는 Single-Thread 라도 Netty 기반의 multiplexing I/O를 지원하기 때문에 초당 10만 요청처리가 가능합니다. 그 외에도 kafka 등을 이용하여 성능향상이 가능한데, 해당 글의 주제는 동시성 제어이므로 자세한 설명은 생략하도록 하겠습니다.  
</br>
Redis는 다시 두 가지 방법으로 나뉘는데, 마찬가지로 해당 글의 주제는 동시성 제어이므로 자세한 설명은 생략하도록 하겠습니다.  
1. Lettuce - redis 기본 패키지에 포함 (setnx: SET if Not eXists)  => (실무) 재시도가 필요하지 않는 lock  
2. Redisson - 오픈 소스 라이브러리 (pub-sub: Message Broker)  => (실무) 재시도가 필요한 경우  

